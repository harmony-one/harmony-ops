<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>harmony_transaction_generator.generator API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>harmony_transaction_generator.generator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import random
import multiprocessing
import itertools
import time
from threading import Lock
from multiprocessing.pool import ThreadPool

from pyhmy import cli
from pyhmy import util
import requests

from .common import (
    Loggers,
    get_config,
    import_account_name_prefix,
)
from .account_manager import (
    create_account,
    get_passphrase,
    send_transaction
)

_implicit_txns_per_gen = 15
_is_running = False
_generator_threads = []
_generator_pool = ThreadPool()


def _get_nonce(endpoint, address):
    &#34;&#34;&#34;
    Internal get nonce to bypass subprocess latency of calling CLI.
    &#34;&#34;&#34;
    url = endpoint
    payload = &#34;{\&#34;jsonrpc\&#34;: \&#34;2.0\&#34;, \&#34;method\&#34;: \&#34;hmy_getTransactionCount\&#34;,&#34; \
              &#34;\&#34;params\&#34;: [\&#34;&#34; + address + &#34;\&#34;, \&#34;latest\&#34;],\&#34;id\&#34;: 1}&#34;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;
    }
    response = requests.request(&#39;POST&#39;, url, headers=headers, data=payload, allow_redirects=False, timeout=30)
    return int(util.json_load(response.content)[&#34;result&#34;], 16)


def generate_to_and_from_shard():
    &#34;&#34;&#34;
    Generate to and from shard randomly follow the config of the transaction generator.
    &#34;&#34;&#34;
    config = get_config()
    shard_choices = list(range(0, len(config[&#34;ENDPOINTS&#34;])))
    src_shard = random.choices(shard_choices, weights=config[&#34;SRC_SHARD_WEIGHTS&#34;], k=1)[0]
    snk_shard = random.choices(shard_choices, weights=config[&#34;SNK_SHARD_WEIGHTS&#34;], k=1)[0]
    retry_count = 0
    if config[&#34;ONLY_CROSS_SHARD&#34;]:
        while src_shard == snk_shard:
            if retry_count &gt; 50:
                Loggers.general.warning(&#34;Trying to force &#39;from&#39; and &#39;to&#39; shards to be different, &#34;
                                        &#34;are source and sink shard weights correct in config?&#34;)
                Loggers.general.write()
            src_shard = random.choices(shard_choices, weights=config[&#34;SRC_SHARD_WEIGHTS&#34;], k=1)[0]
            snk_shard = random.choices(shard_choices, weights=config[&#34;SNK_SHARD_WEIGHTS&#34;], k=1)[0]
            retry_count += 1
    return src_shard, snk_shard


def create_accounts(count, name_prefix=&#34;generated&#34;):
    &#34;&#34;&#34;
    Create `count` accounts where all account-names/wallet-names have the prefix `name_prefix`.
    &#34;&#34;&#34;
    config = get_config()
    assert count &gt; 0
    benchmarking_accounts = []

    def create(start_i, end_i):
        local_accounts = []
        for j in range(start_i, end_i):
            acc_name = f&#34;{import_account_name_prefix}{name_prefix}_{j}&#34;
            create_account(acc_name)
            Loggers.general.info(f&#34;Created account: {cli.get_address(acc_name)} ({acc_name})&#34;)
            local_accounts.append(acc_name)
        return local_accounts

    max_threads = multiprocessing.cpu_count() if not config[&#39;MAX_THREAD_COUNT&#39;] else config[&#39;MAX_THREAD_COUNT&#39;]
    max_threads = min(count, max_threads)
    steps = int(math.ceil(count / max_threads))
    if count &lt; 2:
        benchmarking_accounts = create(0, count)
    else:
        threads = []
        pool = ThreadPool(processes=max_threads)
        for i in range(max_threads):
            threads.append(pool.apply_async(create, (i * steps, min(count, (i + 1) * steps))))
        for t in threads:
            benchmarking_accounts.extend(t.get())
        pool.close()
        pool.join()

    return benchmarking_accounts


def stop():
    &#34;&#34;&#34;
    Stops the transaction generation.
    &#34;&#34;&#34;
    global _is_running

    if not _is_running:
        return
    _is_running = False
    for t in _generator_threads:
        t.get()
    _generator_pool.close()
    Loggers.general.info(&#34;Stopped transaction generator...&#34;)


def start(source_accounts, sink_accounts):
    &#34;&#34;&#34;
    Starts the transaction generation where for each transaction:
    * The source account is chosen in a cyclic order from an account name list called `source_accounts`
    * The sink / destination account is chosen in a cyclic order from an account name list called `sink_accounts`
    * The to and from shards are chosen at random as defined by the shard weights and options in the config.

    Note that the cyclic order starts at the first element and wraps around once it reaches the last element.

    The transaction generator can force each transaction to have a strictly increasing nonce if the
    option is enabled in the config. If nonce forcing is disabled, it is possible to send multiple transactions
    with the same nonce.
    &#34;&#34;&#34;
    global _generator_pool, _is_running
    config = get_config()
    endpoints = config[&#34;ENDPOINTS&#34;]

    if _is_running:
        return
    _is_running = True
    lock = Lock()
    txn_count = 0

    def generate_transactions(src_accounts, snk_accounts):
        nonlocal txn_count
        ref_nonce = {n: [[_get_nonce(endpoints[j], cli.get_address(n)), Lock()] for j in range(len(endpoints))]
                     for n in src_accounts}
        src_accounts_iter = itertools.cycle(src_accounts)
        snk_accounts_iter = itertools.cycle(acc for _ in range(len(src_accounts)) for acc in snk_accounts)
        while _is_running:
            src_name = next(src_accounts_iter)
            src_address = cli.get_address(src_name)
            passphrase = get_passphrase(src_name)
            for _ in range(len(snk_accounts)):
                snk_address = cli.get_address(next(snk_accounts_iter))
                txn_amt = round(random.uniform(config[&#34;AMT_PER_TXN&#34;][0], config[&#34;AMT_PER_TXN&#34;][1]), 18)
                src_shard, snk_shard = generate_to_and_from_shard()
                if config[&#34;ENFORCE_NONCE&#34;]:
                    n, n_lock = ref_nonce[src_name][src_shard]
                    n_lock.acquire()
                    curr_nonce = _get_nonce(endpoints[src_shard], src_address)
                    if curr_nonce &lt; n:
                        n_lock.release()
                        continue
                    if curr_nonce &gt; n:  # sync nonce if too big
                        ref_nonce[src_name][src_shard][0] = curr_nonce
                    ref_nonce[src_name][src_shard][0] += 1
                    n_lock.release()
                if config[&#34;MAX_TXN_GEN_COUNT&#34;] is not None:
                    lock.acquire()
                    if txn_count &gt;= config[&#34;MAX_TXN_GEN_COUNT&#34;]:
                        lock.release()
                        return
                    txn_count += 1 if config[&#34;ENFORCE_NONCE&#34;] else _implicit_txns_per_gen
                    lock.release()
                if config[&#34;ENFORCE_NONCE&#34;]:
                    send_transaction(src_address, snk_address, src_shard, snk_shard, txn_amt,
                                     passphrase=passphrase,  wait=False)
                else:
                    curr_nonce = _get_nonce(endpoints[src_shard], src_address)
                    gen_count = _implicit_txns_per_gen
                    if config[&#34;MAX_TXN_GEN_COUNT&#34;]:
                        gen_count = min(config[&#34;MAX_TXN_GEN_COUNT&#34;] - txn_count, gen_count)
                    for j in range(gen_count):
                        send_transaction(src_address, snk_address, src_shard, snk_shard, txn_amt,
                                         passphrase=passphrase, nonce=curr_nonce+j, wait=False)
            # TODO: put logic here to send transactions as a plan

    Loggers.general.info(&#34;Started transaction generator...&#34;)
    thread_count = multiprocessing.cpu_count() if not config[&#39;MAX_THREAD_COUNT&#39;] else config[&#39;MAX_THREAD_COUNT&#39;]
    thread_count = min(thread_count, len(source_accounts))
    k = max(len(source_accounts) // thread_count, 1)
    _generator_pool = ThreadPool(processes=thread_count)
    for i in range(thread_count):
        thread_src_accounts = source_accounts[i * k: (i + 1) * k]
        _generator_threads.append(_generator_pool
                                  .apply_async(generate_transactions, (thread_src_accounts, sink_accounts)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="harmony_transaction_generator.generator.create_accounts"><code class="name flex">
<span>def <span class="ident">create_accounts</span></span>(<span>count, name_prefix='generated')</span>
</code></dt>
<dd>
<section class="desc"><p>Create <code>count</code> accounts where all account-names/wallet-names have the prefix <code>name_prefix</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_accounts(count, name_prefix=&#34;generated&#34;):
    &#34;&#34;&#34;
    Create `count` accounts where all account-names/wallet-names have the prefix `name_prefix`.
    &#34;&#34;&#34;
    config = get_config()
    assert count &gt; 0
    benchmarking_accounts = []

    def create(start_i, end_i):
        local_accounts = []
        for j in range(start_i, end_i):
            acc_name = f&#34;{import_account_name_prefix}{name_prefix}_{j}&#34;
            create_account(acc_name)
            Loggers.general.info(f&#34;Created account: {cli.get_address(acc_name)} ({acc_name})&#34;)
            local_accounts.append(acc_name)
        return local_accounts

    max_threads = multiprocessing.cpu_count() if not config[&#39;MAX_THREAD_COUNT&#39;] else config[&#39;MAX_THREAD_COUNT&#39;]
    max_threads = min(count, max_threads)
    steps = int(math.ceil(count / max_threads))
    if count &lt; 2:
        benchmarking_accounts = create(0, count)
    else:
        threads = []
        pool = ThreadPool(processes=max_threads)
        for i in range(max_threads):
            threads.append(pool.apply_async(create, (i * steps, min(count, (i + 1) * steps))))
        for t in threads:
            benchmarking_accounts.extend(t.get())
        pool.close()
        pool.join()

    return benchmarking_accounts</code></pre>
</details>
</dd>
<dt id="harmony_transaction_generator.generator.generate_to_and_from_shard"><code class="name flex">
<span>def <span class="ident">generate_to_and_from_shard</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate to and from shard randomly follow the config of the transaction generator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_to_and_from_shard():
    &#34;&#34;&#34;
    Generate to and from shard randomly follow the config of the transaction generator.
    &#34;&#34;&#34;
    config = get_config()
    shard_choices = list(range(0, len(config[&#34;ENDPOINTS&#34;])))
    src_shard = random.choices(shard_choices, weights=config[&#34;SRC_SHARD_WEIGHTS&#34;], k=1)[0]
    snk_shard = random.choices(shard_choices, weights=config[&#34;SNK_SHARD_WEIGHTS&#34;], k=1)[0]
    retry_count = 0
    if config[&#34;ONLY_CROSS_SHARD&#34;]:
        while src_shard == snk_shard:
            if retry_count &gt; 50:
                Loggers.general.warning(&#34;Trying to force &#39;from&#39; and &#39;to&#39; shards to be different, &#34;
                                        &#34;are source and sink shard weights correct in config?&#34;)
                Loggers.general.write()
            src_shard = random.choices(shard_choices, weights=config[&#34;SRC_SHARD_WEIGHTS&#34;], k=1)[0]
            snk_shard = random.choices(shard_choices, weights=config[&#34;SNK_SHARD_WEIGHTS&#34;], k=1)[0]
            retry_count += 1
    return src_shard, snk_shard</code></pre>
</details>
</dd>
<dt id="harmony_transaction_generator.generator.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>source_accounts, sink_accounts)</span>
</code></dt>
<dd>
<section class="desc"><p>Starts the transaction generation where for each transaction:
* The source account is chosen in a cyclic order from an account name list called <code>source_accounts</code>
* The sink / destination account is chosen in a cyclic order from an account name list called <code>sink_accounts</code>
* The to and from shards are chosen at random as defined by the shard weights and options in the config.</p>
<p>Note that the cyclic order starts at the first element and wraps around once it reaches the last element.</p>
<p>The transaction generator can force each transaction to have a strictly increasing nonce if the
option is enabled in the config. If nonce forcing is disabled, it is possible to send multiple transactions
with the same nonce.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(source_accounts, sink_accounts):
    &#34;&#34;&#34;
    Starts the transaction generation where for each transaction:
    * The source account is chosen in a cyclic order from an account name list called `source_accounts`
    * The sink / destination account is chosen in a cyclic order from an account name list called `sink_accounts`
    * The to and from shards are chosen at random as defined by the shard weights and options in the config.

    Note that the cyclic order starts at the first element and wraps around once it reaches the last element.

    The transaction generator can force each transaction to have a strictly increasing nonce if the
    option is enabled in the config. If nonce forcing is disabled, it is possible to send multiple transactions
    with the same nonce.
    &#34;&#34;&#34;
    global _generator_pool, _is_running
    config = get_config()
    endpoints = config[&#34;ENDPOINTS&#34;]

    if _is_running:
        return
    _is_running = True
    lock = Lock()
    txn_count = 0

    def generate_transactions(src_accounts, snk_accounts):
        nonlocal txn_count
        ref_nonce = {n: [[_get_nonce(endpoints[j], cli.get_address(n)), Lock()] for j in range(len(endpoints))]
                     for n in src_accounts}
        src_accounts_iter = itertools.cycle(src_accounts)
        snk_accounts_iter = itertools.cycle(acc for _ in range(len(src_accounts)) for acc in snk_accounts)
        while _is_running:
            src_name = next(src_accounts_iter)
            src_address = cli.get_address(src_name)
            passphrase = get_passphrase(src_name)
            for _ in range(len(snk_accounts)):
                snk_address = cli.get_address(next(snk_accounts_iter))
                txn_amt = round(random.uniform(config[&#34;AMT_PER_TXN&#34;][0], config[&#34;AMT_PER_TXN&#34;][1]), 18)
                src_shard, snk_shard = generate_to_and_from_shard()
                if config[&#34;ENFORCE_NONCE&#34;]:
                    n, n_lock = ref_nonce[src_name][src_shard]
                    n_lock.acquire()
                    curr_nonce = _get_nonce(endpoints[src_shard], src_address)
                    if curr_nonce &lt; n:
                        n_lock.release()
                        continue
                    if curr_nonce &gt; n:  # sync nonce if too big
                        ref_nonce[src_name][src_shard][0] = curr_nonce
                    ref_nonce[src_name][src_shard][0] += 1
                    n_lock.release()
                if config[&#34;MAX_TXN_GEN_COUNT&#34;] is not None:
                    lock.acquire()
                    if txn_count &gt;= config[&#34;MAX_TXN_GEN_COUNT&#34;]:
                        lock.release()
                        return
                    txn_count += 1 if config[&#34;ENFORCE_NONCE&#34;] else _implicit_txns_per_gen
                    lock.release()
                if config[&#34;ENFORCE_NONCE&#34;]:
                    send_transaction(src_address, snk_address, src_shard, snk_shard, txn_amt,
                                     passphrase=passphrase,  wait=False)
                else:
                    curr_nonce = _get_nonce(endpoints[src_shard], src_address)
                    gen_count = _implicit_txns_per_gen
                    if config[&#34;MAX_TXN_GEN_COUNT&#34;]:
                        gen_count = min(config[&#34;MAX_TXN_GEN_COUNT&#34;] - txn_count, gen_count)
                    for j in range(gen_count):
                        send_transaction(src_address, snk_address, src_shard, snk_shard, txn_amt,
                                         passphrase=passphrase, nonce=curr_nonce+j, wait=False)
            # TODO: put logic here to send transactions as a plan

    Loggers.general.info(&#34;Started transaction generator...&#34;)
    thread_count = multiprocessing.cpu_count() if not config[&#39;MAX_THREAD_COUNT&#39;] else config[&#39;MAX_THREAD_COUNT&#39;]
    thread_count = min(thread_count, len(source_accounts))
    k = max(len(source_accounts) // thread_count, 1)
    _generator_pool = ThreadPool(processes=thread_count)
    for i in range(thread_count):
        thread_src_accounts = source_accounts[i * k: (i + 1) * k]
        _generator_threads.append(_generator_pool
                                  .apply_async(generate_transactions, (thread_src_accounts, sink_accounts)))</code></pre>
</details>
</dd>
<dt id="harmony_transaction_generator.generator.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Stops the transaction generation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop():
    &#34;&#34;&#34;
    Stops the transaction generation.
    &#34;&#34;&#34;
    global _is_running

    if not _is_running:
        return
    _is_running = False
    for t in _generator_threads:
        t.get()
    _generator_pool.close()
    Loggers.general.info(&#34;Stopped transaction generator...&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="harmony_transaction_generator" href="index.html">harmony_transaction_generator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="harmony_transaction_generator.generator.create_accounts" href="#harmony_transaction_generator.generator.create_accounts">create_accounts</a></code></li>
<li><code><a title="harmony_transaction_generator.generator.generate_to_and_from_shard" href="#harmony_transaction_generator.generator.generate_to_and_from_shard">generate_to_and_from_shard</a></code></li>
<li><code><a title="harmony_transaction_generator.generator.start" href="#harmony_transaction_generator.generator.start">start</a></code></li>
<li><code><a title="harmony_transaction_generator.generator.stop" href="#harmony_transaction_generator.generator.stop">stop</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>