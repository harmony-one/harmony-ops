

*** Topic for #go-nuts: golang.org | known issues: golang.org/issue |
    https://freenode.logbot.info/go-nuts | don't ask to ask, just ask | don't
    solve problems you don't have | did you check your errors?

[Tue Sep 24 2019]
*** #go-nuts: topic set by
    skelterjohn!sid13218@gateway/web/irccloud.com/x-gfctwrngwpjcjgtp,
    2019-06-18 10:13:21						        [13:18]
*** Users on #go-nuts: Algebr smcquay absc xrash aethlas skywlkr truaal
    edrocks Kvasya kunningd eriswans mmlb mikkeloscar pknull juztin freswa
    troulouliou_div2 pepee Singmyr jnewt1 jnewt mrig tribly hwm4rgs1 Fredrikln
    st8less woshty Edu4rdSHL spectral` nikivi tr4cefl0w andlabs NCS_One
    im0nde1 girafe LambdaComplex Eiam dastier lupine metalinspired tuskkk____
    umeka return0e tharkun _xor dullin Tv` Abjectis knusbaum goldfish ranu
    n1run9 agent_white icholy user9 jolan nanoz mindCrime_
*** Users on #go-nuts: apetresc Raqbit4568 beholders_eye random_yanek sagax
    znedw gst llorllale flexd ct16k Ai9zO5AP Kelzier mingle cjohnson swills
    realvinay mrCyborg imm_ geek1011 black_ant vladimiroff ganbold rif
    karakedi mohan43u _toString libertyprime steven djhworld rabbitear_g
    hendry ilyaigpetrov stutter tomterl guido_g carbocation_sky X-Scale c0ns
    perrier-jouet dithmer grumble defnofdumb misuto gump tristero m0rr1gan
    kajo chasmo77 mutin-sa Orbitrix berglh casaca drazan lanodan
*** Users on #go-nuts: saml iAmerikan epony yzT wmo Jmainguy cpape davic
    Stummi mort TvL2386 Gasher clee jcajka j416 thms_ pmezard deniska
    chachasmooth dhellmann moser raiz mudler FIFOd Stevearzh Freman hays lel
    matteo toshywoshy torin jrwren avoidr swordbeta noettore titouan clinth
    steev bl0m1 carkmorwin atlas bitkeks fub krasnus EvilJStoker m1sc zertox
    sebhoss dabura667 philmacfly mva jlpeters slax0r strmpnk jsvcycling matti
    grandy voker57 oz trom mstruebing dupondje zx2c4 saiban
*** Users on #go-nuts: hl ws2k3 junderw hoodow deanman Y0rick GinjaNinja32
    parazyd endocrimes hugotty aesi paracyst explodes bttf wkalt beppu tvaalen
    loc cyanmide deepend sneak ThiefMaster kormat copypasteque adtac DylanJ
    vqrs minoris lol768 cherti m-kad lurkless argonel DrEeevil CornishPasty
    sangy phI||Ip emilsp Innominate frzr weneg Xu_R dho therealfakemoot jesk
    _jesse_ shroud LoRe Wessie nitrix kris-nova Shawn thevisitor Archwyrm siXy
    zymurgy Who-[Soup] trees rjeli hodapp leee
*** Users on #go-nuts: kerouac jadax xMopx crooked mweckbecker PDP-7 fcanela
    jbraeg a7250ag polyrob pepesza jlaffaye crlane Lieuwex ddevault wizo
    boingolov gnupluslinux mrmoneyc JadoJodo pomaranc dougsko signine1 usil
    utrack ghostbuster agile molz vxn Kurin apragmatist TheMoonMaster sssilver
    Akeem markhuge Zic justinmrkva coredump jscob ius fuchstronaut
    m1sdirection tabakhase jdevlieghere devster31 Zigara jcase LeShadow seanBE
    samfalkner Dr_Jazz toffermann_ Smjert charims pulec
*** Users on #go-nuts: acidchild djoot daved qrwteyrutiyoup babilen nebiros
    ishw0r chamunks Drajwer mrx1 kivutar \13k Tim_Toady multi_io fgau svip
    reda iloop darkphnx4805 infl00p lvlinux trn kubrat _cyril_ pdgwien
    SpydarOO7 circuitbone rudi_s TheBrayn manveru Nizumzen ollien Chepra d10n
    dbarrett [dalek] tomaw d1rewolf erickgnavar beluga0 basepusher aps_
    dolokhov fxrs jj- mjl- Shrike lvmbdv knapptime albertito dec nekron sliang
    xampel d34dh0r53 valwal daed madhatter telling
*** Users on #go-nuts: archwizard56 RayS timthowtdi Shimmy Gaffel bleb moocow
    blackbeard420 KirkMcDonald KBme CrunchyChewie gwd ldh mfrinnstrom
    iamruinous eau mycroft x4b1d lavalike kepler averell hsiktas iYI aerth A_D
    suttin Ekho garvin xorex Gunni kipukun renatogeh laxask Brend MD87 Pillus
    Kamuela nerdy_panda capslocks fotato yitz GyroW zerogue kblin tempora
    TheSeeker bpalmer psil luckman212 jstag jackhill Foxboron e1z0 Vaelatern
    smon GGMethos jsanford MichaelRomig stux|RC
*** Users on #go-nuts: jakobvarmose chauffer strangeqargo hef alnk pez
    tumdedum xnaas arusso teej aramteke debugloop lukad_ bsdbandit KFBI
    eldritch robinsmidsrod spudly muhaha meth michael_mbp wwalker stoebe
    alex88 avu bodqhrohro muesli Kyros mispp dch nachoes hagabaka tallywright
    shibumi lindhe s10g idstam LiENUS victori skind kraem cornfeedhobo wrycode
    Glenjamin orcam rain2 devopsdeluxe martin_ waldhar eruditass coffee
    lsyoyom cliluw rewt lilac lebster rann worstadmin geck
*** Users on #go-nuts: jzelinskie howell cttttt geekodour08 m712 nacelle
    apiarian sam1 haaja since_ leah2 RiPuk stevenroose lstanley forlorn lemmi
    jayjo g2anj notR dxtr j-pb mika halbeno_ dngray Naeblis redlegion mischief
    stefanotorresi mup goodtiding5 xelra ayjay_t Willis prg318 mys_721tx
    Skarlso wnd Sulak dmabs laris kzisme nevivurn lungaro_ sentriz efertone
    exobit wolfshappen mdeous umask077 coyotebush Helio- jiqiren DemonWav
    Teckla underflow p_l elibrokeit robertmeta Seich
*** Users on #go-nuts: ilmostro CodeGeek kinlo gus ebfe jhill Habbie Cork j00n
    fmccann qeed Mutsumi stefanc_diff ffledgling skimmer andi- GJdan
    dostoyevsky untoreh b0nn yawniek leprechau z_fudge c355e3b alm ptx
    dexterlb litheum xSmurf jjhoo alza eyJhb TemporalShift dmgk sauyon flacks
    mdlayher Pseudonosaur defnofdumb[m] pch2013 nghtshd vcanales shapeshed
    +skelterjohn sagaragarwal94 manacit blallo andi_ pro-src sw1nn +Aram
    schaeffer cyp3d_ Disconsented penguwin paroxp alephnull
*** Users on #go-nuts: matrixise tanj foobaz tctw tstellar Natch W1lkins
    wak-work stux|RC-only jinie neffi chder amosbird davidebeatrici mkbloke
    dan drawks cyberlard linuxdaemon ggp0647 novns OnkelUlla joshbaptiste n0pr
    cmars comrad vhost- frameloss johngb riemann ntnn ipcloud mwbrown
    johnnyfive ThatOtherGuy tomku kurahaupo marlinc iivvoo cgfbee cow-orker
    seebs square1 kbabioch sadbox JackK katie_ Martchus_ Petter synthmeat mnx
    Valentine dansan fridim gaz_ gbmor livcd buz sammich
*** Users on #go-nuts: datajerk GnarlyBob BlackMaria dvdmuckle ropeney
    manakanapa callahanca sborza busterbcook ventic ivegotasthma catfuneral
    atlas_ fardog seejy sjums JasonO frobnitz aissen lynchc ExoUNX snits
    daknob aml nobodyspecial420 XenGi termos vila wodim sztanpet luxifer
    dominikh1 student06 shadowchaser t- itsonlybinary minicom Numline1
    strudla_ achillion RainmanNoodles vishwin shoogz Freeaqingme_ kodah^ cnf
    atomi scal_ sedition geoffeg c4rc4s jimInDevNull jinks_ nupogodi
*** Users on #go-nuts: VectorX colekowalski nun dfch nliadm rednul callMeBaby
    tyler569 jej XwZ Cyrus asm89 aleph- xyproto gomix arch3y NightMonkey
    Albori wadadli betawaffle stalled bdd jaguar globbot Logicgate Thinkofname
    josuah pztrn cfel preisi Arahael lithammer Strom ajaiswal jnbek asidorenko
    vroman jrl thenets Prestige segy creatoon stmuk_ justache ossifrage
    bhavin192 andreccosta4 juancate Nilium bookworm duckpuppy shtirlic chancez
    jasonp IonutVan_ Defcronyke psmolen moldybits
*** Users on #go-nuts: maxdamage Patater MrElendig eight_by1 Jackneill
    jcnmark6 hpyc9 subsonik hoonetorg bebbet ezdiy Janhouse
*** #go-nuts modes: +Ccnrtj 10:100
*** #go-nuts was created on 2009-11-09 10:22:37
<Algebr> Looking for some explanation why mutation on nil receiver with double
	 pointer not yielding my intended results of non nil in second method
	 call, seems to imply that go lang does static compile time binding on
	 dispatch https://play.golang.org/p/fxlM_GDY5sv		        [13:19]
<hef> wrapping net.listener sort of works			        [13:23]
<hef> it lets me reuse the listener
<hef> but the original Server.Serve() never returns
<hef> so it's just a leaked goroutine
<ezdiy> hef: just fake the shutdown too				        [13:24]
<ezdiy> and tell the http server to quit
<icholy> Algebr: you're being passed a copy of the pointer which you're then
	 re-assigning.						        [13:25]
<ezdiy> hef: one tricky thing here is that the shutdown will probably bring
	down already running http sessions
<ezdiy> which may be or may be not what you want
<hef> preferably not, but it seems tolerable
<Algebr> icholy: I don't understand, can you elaborate? 	        [13:26]
<ezdiy> if you want to avoid it, just do something dirty to make the Serve()
	bail instantly
<ezdiy> like raise panic() from your fake Accept()
<hef> that sounds pretty dirty
<ezdiy> nah
<ezdiy> as long you expect it above
<ezdiy> tbh this is just nasty hacks, i'd love to see http giving a bit more
	access to its guts, especially when it comes to context stealing
								        [13:27]
<icholy> Algebr: https://play.golang.org/p/NVqWwBNCR5v
<icholy> Algebr: you're just doing that with more steps
*** aleph- (~aleph@lobsters/Auditor/Church-) is now known as Judge_Aleph-
<icholy> Algebr: think of the reciever as any other function parameter. You
	 can re-assign it locally				        [13:28]
<Algebr> right and that's why I take its address so that I can mutate it
<jstag> you are taking the address of a reciever copy, not of the source
	variable you want to modify (w)				        [13:29]
<icholy> Algebr: you're taking the address of the pointer, and then
	 dereferencing it right after
<icholy> Algebr: it's the same thing
<Algebr> How can I achieve what I am trying to do in this code? Is it not
	 possible to get the address of w given just the receiver copy? 
								        [13:30]
<ezdiy> receiver is never passed by value			        [13:31]
<ezdiy> its always a pointer
<ezdiy> if you have x.func(), it's the same thing as if you did func(&x)
<icholy> Algebr: what are you trying to do?			        [13:32]
<icholy> Algebr: how can you get the address of something that doesnt exist?
<ezdiy> he's changing the pointer to the pointer, which is local to the
	function and makes no sense				        [13:33]
<ezdiy> if you want to change the *value* of the receiver, you totally can
<ezdiy> again, receivers behave exactly as if you put ampersand in front of
	variable in a function call				        [13:34]
<icholy> Algebr: are you trying to make a type who's zero value is usable?
								        [13:35]
<Algebr> ezdiy: I'm not clear yet 100% why what I am doing is not changing the
	 value of the receiver, can you provide a go sample that does do that,
	 a modification of my go sample 			        [13:38]
<ezdiy> icholy: there are few suprising this about receivers which may tempt
	one to do certain hacks
<ezdiy> icholy: for instance, https://play.golang.org/p/Tr2fJab1s1f     [13:39]
<ezdiy> naively, "it takes a pointer, i can change that pointer"
<ezdiy> but unfortunately doesn't work that way
<ezdiy> the pointer is taken as is indeed, but then dropped on the floor
								        [13:40]
<ezdiy> Algebr: its not clear what you're trying to do, so first try to make
	an example which does.
<icholy> ezdiy: what's surprising about that code?		        [13:41]
<Algebr> I have a nil receiver on which I call a method in which I want to
	 mutate the receiver to be non-nil and stay non-nil for future method
	 calls. 						        [13:42]
<ezdiy> icholy: to newbies, mostly. they see a pointer, and assume it might be
	somehow changed. because you normally *can* change receiver value, by
	dereferencing receiver pointer when it's taken implicitly to a value
	receiver in the call
<icholy> Algebr: you can't do that
<Algebr> why not						        [13:45]
<ezdiy> Algebr: theres a bar somewhere, avoiding pointer-to-pointer in
	receiver type in method declaration. to simulate what you want is
	simply using uintptr, for instance:
	https://play.golang.org/p/JZX8czxA9dW			        [13:47]
<icholy> Algebr: https://play.golang.org/p/F1ZZVow_rZx
<ezdiy> it's not technically impossible, but it creates ambiguity so i guess
	thats why compiler doesn't allow pointer-to-pointer receiver
<seebs> Algebr: You are taking the address of *your local copy of* the
	pointer. That doesn't help you at all.			        [13:48]
<seebs> And no, in general, you can't make a method mutate the receiver to
	non-nil, that is not how methods work. The usual idiom for a case like
	that isn't a receiver that mutates, it's a receiver that returns the
	new value.						        [13:49]
<ezdiy> i think it's the same reason go does the annoying thing when pointer
	is returned as a value from function, you can't chain it to a method
	call
<ezdiy> as there's a missing ling of missing storage for receiver to safely
	make assumption it can take pointer to			        [13:50]
<ezdiy> *missing link
<seebs> instead of o.BecomeNotNil(), do "o = o.BecomeNotNil()".
<icholy> Algebr: same reason this can't work
	 https://play.golang.org/p/syJrZo7Q78V
<icholy> Algebr: you're operating on a copy
<ezdiy> or do something brutalizing, like use uintptr as a "pointer", and then
	unsafe cast it everywhere when you need it :>		        [13:52]
<seebs> but don't because that will explode randomly later because the gc
	won't know about it
<ezdiy> i mean, if you really insist, solutions can be found. but wont be
	pretty trying to jump over the compiler.
<seebs> also note that you can't just declare a type which happens to be a
	pointer, then do a pointer receiver on that type.
<seebs> type pointerPointer *int				        [13:53]
<seebs> func (p *pointerPointer) mutate(input int) {
<seebs> this will error out because you can't eclare p as a *T when T itself
	is a pointer type
<ezdiy> aka, "pointers are not values as far as receiver is concerned"
<icholy> ezdiy: you can defs do method call chaining
<icholy> ezdiy: you						        [13:54]
<icholy> ezdiy: they are 100% values
<Algebr> thank you 
<Tv`> more like "compiler detects and forbids footguns with that specific
      ornate decor"						        [13:55]
<Tv`> all values are values in Go ;-)				        [13:56]
<ezdiy> icholy: not if receiver needs to take a pointer to return value. it
	can do that to free standing variables, can't do that for return
	values.
<ezdiy> icholy: https://play.golang.org/p/mKwjYqbxAd3
<ezdiy> this arises occasionaly when pointer chaining is not actually desired.
								        [13:57]
<Tv`> that's just a non-addressable value			        [13:58]
<RN1986239> new to go and I wonder why does that generator function work?
	    https://paste.ee/p/PawzQ since from what I learned the context of
	    the closure should be the parent function?
<RN1986239> or does the closure get the context of both the parent function
	    and where it gets returned to?
<icholy> ezdiy: the compiler prevents you from doing that because it's dumb
<ezdiy> it depends						        [13:59]
<ezdiy> it could emit temporary storage
<Tv`> RN1986239: a closure does *not* "get the context of ... where it gets
      returned to"
<ezdiy> totally
<ezdiy> but then it would kinda introduce weird semantic
<ezdiy> if I dereference a receiver and store value to it, I assume to change
	callers variable. now i don't.
<icholy> ezdiy: cool						        [14:00]
<RN1986239> Tv`, I'm mainly confused how this works at all, since all it does
	    is return a function with seemingly uint(0) inside as "ret"
								        [14:01]
<RN1986239> how does it persist its state
<Tv`> RN1986239: i is a "free variable" and just looked up in the surrounding
      scope (makeEvenGenerator)
<ezdiy> tbh, i'd much more prefer if go had statement expressions. ie (_ =
	m.m()).m()
<RN1986239> Tv`, but each time makeEvenGenerator would be called now, wouldnt
	    i be reset to 0?					        [14:02]
<Tv`> RN1986239: ret is just the return variable, nothing special there, just
      awkward horribly written code
<ezdiy> now storage exists for receiver to look at, explicitly
<Tv`> RN1986239: different i
<Tv`> ezdiy: your preferences are overly complex
<Tv`> simple is good, don't write clever code
<icholy> Algebr: this is the best you can do
	 https://play.golang.org/p/RVha-62u3ph
<RN1986239> Tv`, so the example in the book left out some i that was otherwise
	    defined outside of that function?			        [14:03]
<RN1986239> or what other i?
<ezdiy> why? statement expressions are hugely useful and can be use to route
	around "weird" issues like no implicit storage in go
<Tv`> RN1986239: every call of makeEvenGenerator gets fresh local variables
<RN1986239> or does golang treat variables similar to javascript "var" key?
<Tv`> RN1986239: i heartily encourage you to *not* attempt to model all of
      computer science and how computers behave based on javascript; js is a
      hot mess
<RN1986239> Tv`, that means the example wouldn't work then? since all they do
	    is store makeEvenGenerator() in a variable and keep calling it
								        [14:04]
<ezdiy> RN1986239: i only wish go was duck typing like js does
<Tv`> RN1986239: why wouldn't it work?
<ezdiy> at least with interface{}
<RN1986239> Tv`, because the book shows the counter going up, but each time
	    the function is called, wouldnt it get a new i that is uint(0)?
<Tv`> RN1986239: new i per call of makeEvenGenerator		        [14:05]
<Tv`> RN1986239: not per call of the inner function
<RN1986239> oh wait they don't actually call the makeEvenGenerator
<RN1986239> but they call the variable instead
<Tv`> RN1986239: also, this is probably a hint that the book you're reading is
      not very good
<seebs> maybe use ruby? go's syntax is the way it is for considered reasons,
	one of which is that it avoids hiding computational expenses. if you
	want a language that avoids that to let you write terser code, ruby's
	pretty cool.
<RN1986239> so they call the returned function
<RN1986239> wow
<ius> How do I edit a dependency when using modules? It's obviously not as
      simple as editing the dependency and running `go build`
<ius> Must be fairly trivial, but I don't fully grasp modules yet.. any
      pointers?
<Tv`> ius: replace directives in go.mod
<RN1986239> Tv`, yeah, is there any acknowledged good books? I've stumbled on
	    now like 5 of them that were equally as that one..
<Tv`> RN1986239: gopl.io					        [14:06]
<Tv`> ius: there's also a helper utility called "gohack" that basically does
      clone & add replace
<ezdiy> seebs: ruby is really antithesis. the direction i have in mind is more
	like lua, ie drastic orthogonality. unfortunatelity this much
	"semantic toolshed" unfortunately in language design its: simplicity,
	static types, orthogonality. pick two.
<ius> Tv`: right, so right now it obviously points to a git commit - does that
      mean i *need* to commit to be able to reference it?	        [14:07]
<Tv`> ius: replace directives can point to local paths
<ius> I'd be okay with 'just use the dirty working tree'
<RN1986239> Tv`, thanks!					        [14:08]
<ius> ah! it's a directive
<ius> thought you meant 'do a replace'
<RN1986239> Tv`, still one question, how does the book author get a number
	    returned, if the return statement is empty in the returned
	    function though?					        [14:10]
<RN1986239> shouldn't it return ret then?
<Tv`> RN1986239: this is why i called the code crap, and the book bad   [14:11]
<RN1986239> it's a typo?
<Tv`> RN1986239: you've stumbled on a "naked return" with no reason to exist
<Tv`> RN1986239: see the func line, after parens, says `(ret uint)`     [14:12]
<bpalmer> RN1986239: if a return parameter is named, a 'return' by itself uses
	  the last value assigned to each
<Tv`> RN1986239: that means if the return doesn't say what to return, return
      the current value of ret
<Tv`> RN1986239: there's no reason to do that in your example, it's just crap
      code
<RN1986239> Tv`, so "ret" is some sort of magic parameter? or does return
	    return all the parameters passed to it		        [14:13]
<RN1986239> a naked return I mean
<Tv`> normal code would say something like `return i`		        [14:14]
<Tv`> i'm not gonna justify the author's bad code
<RN1986239> exactly what confused me
<RN1986239> just wondering how golang functions in that situation
<RN1986239> and why it works at all
<Tv`> https://golang.org/ref/spec#Return_statements		        [14:15]
<ius> Tv`: I failed to get the replace directive right, so tried gohack -
      works wonders - thanks, exactly what i needed
<Tv`> RN1986239: but seriosly, stop trying to learn from bad sources    [14:16]
<Tv`> ius: sure, but important to understand how it works and what it does
<RN1986239> Tv`, just trying to understand how this hack worked at all, as
	    coming from other languages it looked wild
<Tv`> ius: also, make sure to never commit that hacked go.mod
<Tv`> RN1986239: that'll be easier later			        [14:17]
<ius> Tv`: yeah, it showed me that the replace directive should be top level -
      i nested it in the require()
<ius> :)
<RN1986239> Tv`, oh wow yeah in your link I see case 3 explaining it
<RN1986239> Tv`, never actually seen anything like that before lol
<Tv`> ius: see also go mod edit
<RN1986239> Tv`, guess for a good reason too			        [14:18]
<RN1986239> Tv`, now I also understand what bpalmer meant, since the function
	    actually named the return values prior
<bpalmer> RN1986239: the concept shows up in things like ada, with explicit
	  'out' parameters.					        [14:19]
<Tv`> lots of "out parameters" used in C too
<Tv`> less explicit, but hey it's C
<bpalmer> procedure sum(A, B: in Integer; C out Integer) is begin C := A + B;
	  end sum
<RN1986239> just never came across it to be honest, at all	        [14:20]
<ius> Tv`: ah, thats useful as well
<rodrigc> I'm trying to convert a project from using govendor to using go
	  modules, and on this line:
	  https://github.com/libopenstorage/openstorage/blob/master/vendor/vendor.json#L2137
								        [14:24]
<rodrigc> I cannot find `go.pedge.io/lion` , `go.pedge.io/env`, etc.
<rodrigc> what do I do if https://go.pedge.io is not in DNS, and I can't find
	  the library on GitHub?				        [14:25]
<Tv`> rodrigc: seems like peter edge screwed up the hosting	        [14:26]
<rodrigc> I saw some references but could not find
	  https://github.com/peter-edge/ either
<Tv`> rodrigc: looks like a case of someone erasing themselves off the
      net. good luck!						        [14:27]
<rodrigc> oh my
<Tv`> e.g. https://godoc.org/go.pedge.io/proto/time confirms the github url
<Tv`> obviously that's just a cached page			        [14:28]
<rodrigc> https://godoc.org/go.pedge.io returns an error
<Tv`> not cached...
<rodrigc> in the Go world, what is the typical solution to this kind of
	  problem, where I may vendor a 3rd party library, but then that
	  library vanishes off the face of the earth?		        [14:29]
<ezdiy> Now imagine, ifImicrosoft was really really evil, they could just
	start charging money for abusing the site as module repository.
<Tv`> rodrigc: well if you actually vendored it, you'd have the old code
<rodrigc> ezdiy: shhhh, don't give anyone any ideas...
<Tv`> rodrigc: in the brave new world of modules, you'd have the .zip, perhaps
      even on the global proxy
<ezdiy> rodrigc: it's not all that original. i mean npm does that even though
	it seemed like a ridiculous concept at first. yet here we are.
<rodrigc> Tv`: well, I'm trying to transition to modules	        [14:30]
<Tv`> rodrigc: if you had fetched this through proxy.golang.org, it'd ideally
      still have a copy
<rodrigc> so I ran `env GO111MODULE=on go mod init`
<rodrigc> to make the go.mod file
<Tv`> rodrigc: of course nothing prevents DMCA/GDPR-style takedowns there, if
      someone really wants to be erased
<rodrigc> then I did `go mod vendor`				        [14:31]
<Tv`> rodrigc: at this point i'd recommend you work with openstorage to write
      them away from using these dead packages first, and then migrate to
      modules
<Tv`> rodrigc: you're too late to save the data now
<rodrigc> can I manually populate the vendor tree with stuff vendored in from
	  the old govendor?
<Tv`> rodrigc: perhaps (depends on what the hell govendor actually did), but
      you don't want to use vendoring forever either		        [14:32]
<ezdiy> i find it hilarious that a package called 'open storage' has
	apparently build problems because it even fails to store its own
	source code.
<Tv`> actually to make progress right now, just copy the pedge/lion files from
      whereever you have them into e.g. third_party/lion and put a replace
      directive with ./third_party/lion in your go.mod
<rodrigc> ezdiy: openstorage has the dependencies vendored in a few years ago
	  using govendor.  I'm trying to convert this library to go modules
								        [14:34]
<ezdiy> ah
<ezdiy> guess you can just re-spawn the repository when worst come to worst
								        [14:35]
<rodrigc> it looks like Peter Edge had quite a few libraries
<ezdiy> guess there's a good use for vendoring after all
<ezdiy> archiving broken websites
<rodrigc> ezdiy: exactly
<rodrigc> if I look at https://www.google.com/search?q=%22peter+edge%22+golang
	  , there are a lot of references to go libraries by peter edge
<ezdiy> (i'm a git submodule nazi, and would suffer badly with a broken link)
								        [14:36]
<rodrigc> I'm coming from the Python world, where everyone just does "pip
	  install", and all the Python packages are in one centralized
	  repository.  That has its pros and cons		        [14:38]
<ezdiy> i still have nightmares about pip and easyinstall	        [14:40]
<ezdiy> python is like 90% "it just works"
<ezdiy> and 10% inobinable nightmware figuring out what broke when it doesnt
<rodrigc> ezdiy: I've had similar experiences with Ruby packages        [14:43]
<jrwren> how is that python world pip install any different from go get ?
								        [14:44]
<jrwren> oh i see, the distributed nature was the context. sorry. nevermind.
								        [14:45]
<freswa> Hey people :) I'm looking for a package which I can use to build a
	 cli tool for a daemon communicating over a socket. Is there nothing
	 more specific than stuff like gRPC?			        [14:50]
<rodrigc> jrwren: `go get` poses interesting challenges if the upstream
	  repository gets deleted, renamed, moved around, etc.  if
	  Sirupsen/logrus means anything to you, you will know what I mean
<jrwren> indeed, and yet, now that proxy.golang.org caches things, isn't it a
	 non issue?						        [14:51]
<ezdiy> jrwren: does it cache indefinitely though?		        [14:54]
<ezdiy> proxy.golang.org does not save all modules forever. There are a number
	of reasons for this, but one reason is if proxy.golang.org is not able
	to detect a suitable license. In this case, only a temporarily cached
	copy of the module will be made available, and may become unavailable
	if it is removed from the original source and becomes outdated.
								        [14:55]
<jrwren> good question. i do not know.
<ezdiy> wow, rude
<ezdiy> still, anything worth anything probably has a license	        [14:56]
<rodrigc> this reddit post mentions something about peter edge changing his
	  username:
	  https://www.reddit.com/r/golang/comments/cc7lzx/githubcompeteredgepkggoyaml_no_longer_accessible/
	  but the golang-dev link mentioned there doesn't point to anything
	  for me						        [15:01]
<shipit> any gorm fans? I'm considering it ...			        [15:39]
<shipit> watching myself create same patterns
<b0nn> shipit: Most Go people advocate /against/ ORMs		        [15:59]
<shipit> I hear ya- I just want a generic way of CRUD into/out of a DB  [16:00]
<shipit> I keep writing structs and filling 'em w Scans() ie mysql driver
								        [16:01]
<shipit> thinking how to reduce the boilerplate
<Zigara> shipit: check out sqlx					        [16:04]
<shipit> Zigara looks nice! thanks :)				        [16:05]
<ezdiy> my approach to golang database is to gop everything to disk every 10
	minutes							        [16:06]
<ezdiy> ungop it on startup
<ezdiy> voila, there's your ORM
<shipit> gop / ungop?						        [16:07]
<ezdiy> shipit: its not really database, just quick and dirty state
	serialization
<shipit> ah
<ezdiy> that knows pointers and pretty much all go data types
<Zigara> by gop do you mean gob?
<ezdiy> ye
<Zigara> it can certainly get the job done			        [16:08]
<ezdiy> in the ideal world it would be really nice if it was possible to have
	concept of images like smalltalk
<ezdiy> Zigara: point being, a lot of time people opt for database when
	there's little need for any, or it's actively counter to the data
	structures they're book keeping				        [16:09]
<ezdiy> if its a deep tangle of various reference trees, its really hard to
	map that to db
<Zigara> I agree
<shipit> this is very useful discussion!			        [16:10]
<Zigara> shipit: in case you were wondering;
	 https://golang.org/pkg/encoding/gob/			        [16:11]
<ezdiy> db is still great if you want ability to execute powerful queries
<shipit> thx Zigara, on there atm
<ezdiy> doing that in program can still be a lot of time
<ezdiy> s/time/pain
<b0nn> shipit: what exactly are you using the DB for?		        [16:34]
<b0nn> I mean, is it being used purely for persistence of data
<b0nn> or is it also being used as a means of communicating between
       components?
<shipit> b0nn yea, just persisting records and updating columns for status and
	 values that the workflow updates which is spread across containers
<shipit> I'm checkpointing data and communicating using redis across processes
	 and channels within process				        [16:35]
<shipit> both abstracted by structs that are backed by DB row
<b0nn> status and values spread across containers: I'd look at how that's a
       good use of a database					        [16:36]
<b0nn> You're communicating between components using the (shared) database
<shipit> no - nothing listens to it, upsert and pass the rowID w/ channel or
	 redis based queue					        [16:37]
<shipit> so if the channel or redis bonks, I can recover	        [16:38]
<ezdiy> probably just slap gobed (or even json if its simple enough to map to
	that) state directly into redis directly		        [16:40]
<ezdiy> afaik the thing can persist to disk with snapshots
<shipit> since I'm running across containers in kubernetes cluster, these can
	 lose persistence even w/ a pvc				        [16:43]
<shipit> so my db is managed instance that is source of truth and I want to be
	 able to recover from a state when necessary		        [16:44]
<ezdiy> shipit: ah, i assumed that you have single redis as a central
	synchronization point for that, and the sql just to abuse orm for
	fancy struct serialization				        [16:47]
<ezdiy> (sorry for assuming, professional scarring from seeing horrible things
	like that already)					        [16:48]
<shipit> yea- idk whats the correct solution, new to Go :) from Android/Java
	 land
<shipit> redis is in-cluster, cluster spins up, buncha pods do their thing and
	 talk to each other via redis but keep updating the DB for progress of
	 work -- eventually maybe replace redis w/ kafka	        [16:50]
<ezdiy> its hard to say without knowing whats going on. personally i'm just
	big fan of spamming everything to disk as json files. filesystems are
	reliable. json files are near human readable. and it's usually fast
	enough.
<shipit> totally - I love the `json:"field"` and serialize that to disk or
	 over the wire						        [16:51]
<shipit> but I'm poor so deploying pre-emptible VMs
<ezdiy> yea if its domain separation you're after (i assume given the whole
	kubernetes stuff), simple things are not necessarily the way
								        [16:53]
<ezdiy> when the point is to restrict what each domain can and cannot do
<shipit> yea unidirectional flow, do one thing, pass on to next guy (announce)
<shipit> eg there's a container that reads announcement and broadcasts row(s)
	 to web client when session/web-socket active		        [16:55]
<ezdiy> would be really neat if something like channels that can persist if
	both source and sink go down
<shipit> yea- that'd be awesome
<shipit> but I think thats what kafka, RabbitMQ etc are		        [16:56]
<ezdiy> ie a sends to b, b is busy so it sits in channel, a and b both crash,
	a and b go up, and b receives from persisted chan what was sent before
<shipit> hmmm
<ezdiy> not sure kafka rabbitmq etc do the persistence, i thought those were
	all online, not ACID
<shipit> I'm not sure either, I read about them in passing
<shipit> persisted channel sounds nice, additionally how to scale across zones
								        [16:57]
<ezdiy> closest to it would be probably some sort of log database. i mean
	actual real world channels world in similar fashion (ring buffer)
								        [16:58]
<ezdiy> so you have a log, you have a reader pointer and you have a writer
	pointer at the tip
<shipit> hmm - reminds if of one time we used oracle for disaster recovery
	 using its journaling
<ezdiy> all pointers and the log are reliably persisted somehow
<shipit> increment on read?					        [16:59]
<shipit> if I have >1 go routines blocked on the p-channel?
<ezdiy> well, ideally you'd keep it single writer, single reader        [17:01]
<ezdiy> multiple writer and multiple reader are nontrivial cases, as you now
	have to deal with write order. serialization of events is often a big
	thing in pipe models
<ezdiy> so in practice, you'd keep all channels SPSC (single producer, single
	consumer), but a process can be consumer of both at run time via
	actual goroutines and decide how to merge two inputs coming in
								        [17:02]
<shipit> fair fair
<ezdiy> but the actual pipe going over network/disk whatever - no, dont try
	multiplicity there
<ezdiy> so rabbitmq has apparently persistent queues		        [17:04]
<shipit> the wisdom I grokked there was rmq wants big machines and kafka is
	 better at horizontal scaling				        [17:05]
<ezdiy> which is more or less this. if consumer is down, rbmq queues to disk
	until consumer goes up. can survive restarts etc.
<ezdiy> shipit: technically there might not be even need for central
	synchronization point. if the producers/consumers can track context on
	their own. that's a lot of cooking of your own stuff, but if you're
	concerned by scaling, you'd want to do that anyway.	        [17:08]
<ezdiy> but yea kafka seems like a giant java thing that can shard into
	multiple instances. i'd be scared of it if something went wrong
	though.							        [17:09]
<tylerdmace> Hello! Can anyone tell me a good pattern to use wherein I have an
	     http handler that needs to kick start a timer if one is not
	     already running? I need all instances of this function to refer
	     to the same timer and I need to be able to cancel the timer if
	     necessary.						        [17:10]
<shipit> yea- in k8s context, a persisted queue/pub-sub needs to be outside
	 the cluster or atleast the storage is -- not sure how to approach
	 that yet
<shipit> is there no Go based MQ?
<shipit> we're done w Java :p
<shipit> kotlin native maybe but yea
<bpalmer> tylerdmace: you're trying to cancel the timer or start it?    [17:11]
<ezdiy> shipit: there's ton of those actually. http://queues.io
<tylerdmace> bpalmer: both.. if a timer isn't running, I need to start
	     one... and depending on some other variables, I may need to
	     cancel/restart the existing timer
<bpalmer> a closure as the handler -- making the timer sort of a middleware
	  piece -- seems like the straightforward approach
<ezdiy> shipit: its just am opinionated and scared of things i cant read
	source code of in one sitting
<shipit> ezdiy I feel you					        [17:12]
<bpalmer> http.Handle("/foo", WithTimer(fooHandler))
<tylerdmace> interesting. Ok, thank you!
<shipit> ezdiy: I want to stay vendor neutral esp cloud hosted ones 'cause I
	 can pick up my k8s deployment and go to any other provider
<bpalmer> tylerdmace:
	  https://www.alexedwards.net/blog/making-and-using-middleware shows
	  some examples of wrapping code around the core handler        [17:14]
<ezdiy> shipit: beanstalk, ironmq, nats, nsq, siberite,
<tylerdmace> bpalmer: Thank you, friend. This is helpful.
<ezdiy> these all seem to be in go, often backed by simple K/V store which can
	be perhaps pluggable for cloud service hosting where you often get
	some sort of K/V bucket db				        [17:15]
<bpalmer> another option, if you don't need to create generic timer-aware
	  functions, is to simply use handlers that are attached to a struct
	  that has a timer.					        [17:16]
<bpalmer> s := &MyThing{timer.New(5*time.Second)};
	  http.Handle("/foo",s.handleFoo)			        [17:17]
<bpalmer> then func (s *MyThing) handleFoo(...) {  ... }  can just refer to
	  s.Timer
<adiabatic> I have an interface called models.BagManager. They manage Bags,
	    which are something that a User owns. BagManager has a method
	    named ByID(uint) that retrieves a bag, by ID, from the
	    database. However, I kind of want to keep this function around in
	    some form…but I really should be primarily using a method
	    (tentatively) called ByIDForUser(uint, *User) that ensures that
	    the given user actually owns the bag in question. What should I
	    rename B
<adiabatic> yID(uint) to to keep me from using it when I should be using the
	    permissions-checking one?
<bpalmer> ByIDUnauthenticated()? ByIDRaw() ?  ByIDAreYouSureYouWannaCallMe() ?
	  ByIDBadIdeaHombre() ?					        [17:19]
<adiabatic> I thought "UnsafeByID()" wasn't awful, but I wondered if I could
	    do better.
<bpalmer> RawLookupByID() might not be so bad.			        [17:20]
<ezdiy> this is why one should name methods by single capital letter and a
	number
<bpalmer> Unsafe, to me, would make me even more paranoid, because it is
	  suggestive of unsafe memory access
<ezdiy> adiabatic: tbh, i'd just include verb			        [17:21]
<ezdiy> missing verbs make it hard to interpret
<adiabatic> ezdiy: not sure what you mean yet			        [17:22]
<adiabatic> What about UnauthenticatedByID()? It doesn't sort with the method
	    I want, it's long and annoying, and "unauthenticated" sounds like
	    just the right amount of bad
<ezdiy> GetById, GetByIdUserCheck
<ezdiy> verb actually denoting the action
<adiabatic> Oh.							        [17:23]
<ezdiy> adiabatic: anyhow, this is just personal preference, i doubt theres
	"the way" one way or another
<adiabatic> I thought Go style was "if it's kind of like an accessor, omit the
	    'Get'.". Am I wrong?
<adiabatic> ezdiy: sure, but even with that, there's almost certainly "more
	    better" and "more worse"				        [17:24]
<ezdiy> its not necessarily a getter
<ezdiy> it actually gets the data from somewhere else. also the write
	equivalent could be Put(), especially if external referene is taken
	too etc
<ezdiy> adiabatic: as a rule of thumb, 3 words max. verb for things like 'get'
	could be implied, but for things like 'search' (by some criteria),
	definitely not						        [17:26]
<adiabatic> well, it's used in things like  `bag, err := bagsManager.ByID(id)`
								        [17:27]
<ezdiy> thats perfectly fine, am just nitpicking. i'd go just with something
	horrible, like bagsManager.Get(id, user). where user could be nil
	implying no check.					        [17:28]
<ezdiy> mostly of sheer lazyness				        [17:29]
<adiabatic> I could see myself accidentally passing a nil pointer to the
	    second param of that
<adiabatic> after forgetting to do a proper nil check
<bpalmer> ezdiy: I think having a separate function is a best practice; that
	  way you can have code review or a linter specifically flag
	  problematic functions
<ezdiy> adiabatic: can use sentinels
<ezdiy> var DontCheckUser = &User{}				        [17:30]
<ezdiy> compare to that
<adiabatic> I did think of that. Have some sort magical User with a hidden
	    flag set that lets it muck with anybody's bags?
<adiabatic> Zero values seem too easy to accidentally create.	        [17:31]
<bpalmer> even better might be something like 'ById(uint);' and a separate
	  interface that exposes an admin functionality
<ezdiy> adiabatic: sentinels are bad to have lying around as actual state,
	this is just purely for pointer comparison
<ezdiy> bpalmer: code coverage? whats that. it compiles, ship it!
<ezdiy> it keeps randomly crashing? put in top level panic handler that
	re-exec the app on crash to get a clean slate		        [17:32]
<adiabatic> "separate interface that exposes admin functionality" seems
	    awfully baroque to me — I'm still only just keeping up having one
	    interface that's implemented by a stack of gorm-accessing and
	    parameter-validating classes			        [17:33]
<ezdiy> thats what buzzwords like RAD actually translate into
<adiabatic> rapid application development?
<ezdiy> ye
<bpalmer> like, suppose users can get their own bags at the baggage claim; but
	  agents need to be able to look up everything. Then
	  'ByUserAndId(*user, uint)'. Also have  'AsAgent(*user)
	  PrivilegedBagsManager'
<bpalmer> where PrivilegedBagsManager is exported from the same package and
	  accesses BagsManager.byID(uint)  (note the unexported method)
								        [17:34]
<bpalmer> then AsAgent can make sure that the passed in user is actually an
	  agent and should have super-user privileges
<adiabatic> I _am_ tempted to unexport the unsafe ByID method.
<ezdiy> adiabatic: dont bother unless its unexported struct too	        [17:35]
<ezdiy> if its just private method of public struct, someone will eventually
	reflect it sooner or later
<bpalmer> not in any healthy code base.
<ezdiy> thats why small letters are reserved only for things one is embarassed
	about, not for "security"
<adiabatic> well, when I'm thinking about intra-codebase defense, I tend to
	    think of only defenses that I'd need against sleepy programmers
	    who didn't read the docs closely enough — not actively malicious
	    nosy other programmers				        [17:37]
<ezdiy> bpalmer: theres no healthy codebase when i t comes to libraries hiding
	core functionality. there's just opinionated decisions to arbitrarily
	hide useful method.
<ezdiy> so library user comes along, facing a choice: fork it just to fix the
	arbitrary decision, or reflect
<ezdiy> adiabatic: that's always the rationale for hiding stuff. others *will*
	read the code if they need the function your public interface doesn't
	expose, but it actually exists.				        [17:39]
<adiabatic> Sounds like "make the name scary, but don't hide it" is the better
	    option, then.					        [17:40]
<ezdiy> to me, most definitely
<ezdiy> though its generally not "the go way", especially if you look at
	standard runtime
<ezdiy> its obsessed with hiding stuff. theres probably decent rationale for
	that though in terms of dead code elimination and other optimizations
	based on locality					        [17:41]
<ezdiy> (currently the compiler is hopeless and doesn't care, except for
	symbols)						        [17:42]
<adiabatic> also: you can publish private stuff, but you can't unpublish
	    public stuff until go 2
<ezdiy> yep
<ezdiy> adiabatic: i think best example to do this is packages like ed25519
								        [17:43]
<ezdiy> in standard go, you get only the bare function - sign, verify,
	generate keys, thats it
<ezdiy> you can prod the Ec math beneath, hash to points no nothing. then
	there exists api-compatible package from same author, which exposes
	additional stuff in extras/				        [17:44]
<ezdiy> so you import the dangerous stuff from separate namespace
<adiabatic> but
	    https://godoc.org/golang.org/x/crypto/ed25519/internal/edwards25519
	    has a lot of stuff in it
<ezdiy> and must explicitly do so
<ezdiy> yep. notice internal/
*** qwe__ (~kunningdr@unaffiliated/kunningdruger) is now known as kunningd
<adiabatic> yup
<bpalmer> adiabatic: the privileged interface is, I think, the *best*
	  approach. But it is a little bit more work.		        [17:46]
<adiabatic> bpalmer: Under what conditions would it be clearly the best
	    option? If I had a bunch of different no-admin functions AND a
	    bunch of admin functions?				        [17:47]
<ezdiy> adiabatic: i'm personally for letting users shoot themselves in the
	foot, but in practice i've seen best outcomes with 2-level api split:
	low level that is the individual atomic parts of the system. public,
	but tedious to use. and then intensely dumbed down and extensively
	documented interface for users who are likely to shoot themselves in
	the foot in the first place.				        [17:49]
<ezdiy> the idea is that sleepy programmers will use the dumbed down interface
<ezdiy> and the user that wants fancy, jumps the hoops with atomics
<bpalmer> adiabatic: in a large codebase, with many people, you want to have
	  as few explicit authorization checks sprinkled around as
	  possible. Having a more attractive option that takes both *user and
	  id  is a good first step, but it still doesn't ergonomically focus
	  people's attention on when the other one should be used.
<adiabatic> ezdiy: that makes sense, but this is a web app with just me
	    programming it in various states of sleepyness
<adiabatic> bpalmer: ooh, gotcha
<adiabatic> ezdiy: …I think that makes it more difficult for me to tell the
	    difference between plumbing and porcelain, to use the Git
	    terminology						        [17:50]
<adiabatic> s/tell the difference/feel the difference/		        [17:51]
<ezdiy> adiabatic: to be fair, to make the clear line one needs sufficiently
	complex system						        [17:52]
<ezdiy> which simple CRUDs often fail to be
<adiabatic> yeah, no argument there
<ezdiy> adiabatic: tbh, if its just a web app, who cares about security and
	consistency :> just make sure resources are reasonably
	capped/sandboxed when something gets into runaway states it wont crash
	your box						        [17:56]
<ezdiy> i mean just look at browsers and javascript. standards are
	encouraginly low, no need to overdo it when rest of the ecosystem
	essentially doesn't care anyway.			        [17:57]
<ezdiy> (this is me talking after fighting with overzealous-escaping in a html
	template yet again)					        [17:58]
<ezdiy> i swear there will be class of double and triple escape bugs one day
								        [17:59]
*** pepee_ (~pepee@unaffiliated/pepee) is now known as pepee	        [18:07]
*** Judge_Aleph- (~aleph@lobsters/Auditor/Church-) is now known as aleph-
								        [18:50]
ERC> 
